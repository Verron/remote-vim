{
    "json_decode": "json_decode\n\n(PHP 5 >= 5.2.0, PECL json >= 1.2.0)\njson_decode - Decodes a JSON string\n",
    "Description": "Description\n\nmixed json_decode ( string $json [, bool $assoc = false [, int $depth = 512 [,\nint $options = 0 ]]] )\nTakes a JSON encoded string and converts it into a PHP variable.\n",
    "Parameters": "Parameters\n\n  assoc\n      When TRUE, returned objects will be converted into associative arrays.\n  depth\n      User specified recursion depth.\n  options\n      Bitmask of JSON decode options. Currently only JSON_BIGINT_AS_STRING is\n      supported (default is to cast large integers as floats)\n",
    "Return Values": "Return Values\n\nReturns the value encoded in json in appropriate PHP type. Values true, false\nand null are returned as TRUE, FALSE and NULL respectively. NULL is returned if\nthe json cannot be decoded or if the encoded data is deeper than the recursion\nlimit.\n",
    "Examples": "Examples\n\nExample #1 json_decode() examples\n<?php\n$json\u00a0=\u00a0'{\"a\":1,\"b\":2,\"c\":3,\"d\":4,\"e\":5}';\n\nvar_dump(json_decode($json));\nvar_dump(json_decode($json,\u00a0true));\n\n?>\nThe above example will output:\nobject(stdClass)#1 (5) {\n    [\"a\"] => int(1)\n    [\"b\"] => int(2)\n    [\"c\"] => int(3)\n    [\"d\"] => int(4)\n    [\"e\"] => int(5)\n}\n\narray(5) {\n    [\"a\"] => int(1)\n    [\"b\"] => int(2)\n    [\"c\"] => int(3)\n    [\"d\"] => int(4)\n    [\"e\"] => int(5)\n}\nExample #2 Accessing invalid object properties\nAccessing elements within an object that contain characters not permitted under\nPHP's naming convention (e.g. the hyphen) can be accomplished by encapsulating\nthe element name within braces and the apostrophe.\n<?php\n\n$json\u00a0=\u00a0'{\"foo-bar\":\u00a012345}';\n\n$obj\u00a0=\u00a0json_decode($json);\nprint\u00a0$obj->{'foo-bar'};\u00a0\/\/\u00a012345\n\n?>\nExample #3 common mistakes using json_decode()\n<?php\n\n\/\/\u00a0the\u00a0following\u00a0strings\u00a0are\u00a0valid\u00a0JavaScript\u00a0but\u00a0not\u00a0valid\u00a0JSON\n\n\/\/\u00a0the\u00a0name\u00a0and\u00a0value\u00a0must\u00a0be\u00a0enclosed\u00a0in\u00a0double\u00a0quotes\n\/\/\u00a0single\u00a0quotes\u00a0are\u00a0not\u00a0valid\u00a0\n$bad_json\u00a0=\u00a0\"{\u00a0'bar':\u00a0'baz'\u00a0}\";\njson_decode($bad_json);\u00a0\/\/\u00a0null\n\n\/\/\u00a0the\u00a0name\u00a0must\u00a0be\u00a0enclosed\u00a0in\u00a0double\u00a0quotes\n$bad_json\u00a0=\u00a0'{\u00a0bar:\u00a0\"baz\"\u00a0}';\njson_decode($bad_json);\u00a0\/\/\u00a0null\n\n\/\/\u00a0trailing\u00a0commas\u00a0are\u00a0not\u00a0allowed\n$bad_json\u00a0=\u00a0'{\u00a0bar:\u00a0\"baz\",\u00a0}';\njson_decode($bad_json);\u00a0\/\/\u00a0null\n\n?>\nExample #4 depth errors\n<?php\n\/\/\u00a0Encode\u00a0the\u00a0data.\n$json\u00a0=\u00a0json_encode(\n\u00a0\u00a0\u00a0\u00a0array(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0=>\u00a0array(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'English'\u00a0=>\u00a0array(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'One',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'January'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'French'\u00a0=>\u00a0array(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'Une',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'Janvier'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\n\u00a0\u00a0\u00a0\u00a0)\n);\n\n\/\/\u00a0Define\u00a0the\u00a0errors.\n$constants\u00a0=\u00a0get_defined_constants(true);\n$json_errors\u00a0=\u00a0array();\nforeach\u00a0($constants[\"json\"]\u00a0as\u00a0$name\u00a0=>\u00a0$value)\u00a0{\n\u00a0\u00a0\u00a0\u00a0if\u00a0(!strncmp($name,\u00a0\"JSON_ERROR_\",\u00a011))\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0$json_errors[$value]\u00a0=\u00a0$name;\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\/\/\u00a0Show\u00a0the\u00a0errors\u00a0for\u00a0different\u00a0depths.\nforeach\u00a0(range(4,\u00a03,\u00a0-1)\u00a0as\u00a0$depth)\u00a0{\n\u00a0\u00a0\u00a0\u00a0var_dump(json_decode($json,\u00a0true,\u00a0$depth));\n\u00a0\u00a0\u00a0\u00a0echo\u00a0'Last\u00a0error:\u00a0',\u00a0$json_errors[json_last_error()],\u00a0PHP_EOL,\u00a0PHP_EOL;\n}\n?>\nThe above example will output:\narray(1) {\n  [1]=>\n  array(2) {\n    [\"English\"]=>\n    array(2) {\n      [0]=>\n      string(3) \"One\"\n      [1]=>\n      string(7) \"January\"\n    }\n    [\"French\"]=>\n    array(2) {\n      [0]=>\n      string(3) \"Une\"\n      [1]=>\n      string(7) \"Janvier\"\n    }\n  }\n}\nLast error: JSON_ERROR_NONE\n\nNULL\nLast error: JSON_ERROR_DEPTH\nExample #5 json_decode() of large integers\n<?php\n$json\u00a0=\u00a0'{\"number\":\u00a012345678901234567890}';\n\nvar_dump(json_decode($json));\nvar_dump(json_decode($json,\u00a0false,\u00a0512,\u00a0JSON_BIGINT_AS_STRING));\n\n?>\nThe above example will output:\nobject(stdClass)#1 (1) {\n  [\"number\"]=>\n  float(1.2345678901235E+19)\n}\nobject(stdClass)#1 (1) {\n  [\"number\"]=>\n  string(20) \"12345678901234567890\"\n}\n",
    "Notes": "Notes\n\n     Note:\n     The JSON spec is not JavaScript, but a subset of JavaScript.\n     Note:\n     In the event of a failure to decode, json_last_error() can be used to\n     determine the exact nature of the error.\n",
    "Changelog": "Changelog\n\nVersion Description\n5.6.0   Invalid non-lowercased variants of the true, false and null literals\n        are no longer accepted as valid input, and will generate warnings.\n5.4.0   The options parameter was added.\n5.3.0   Added the optional depth. The default recursion depth was increased\n        from 128 to 512\n5.2.3   The nesting limit was increased from 20 to 128\n5.2.1   Added support for JSON decoding of basic types.\n",
    "See Also": "See Also\n\n    * json_encode() - Returns the JSON representation of a value\n    * json_last_error() - Returns the last error occurred\n[add_a_note]_add_a_note\n"
}